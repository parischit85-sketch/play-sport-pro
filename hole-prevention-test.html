<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Prevenzione Buchi 30 Minuti</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-case { border: 1px solid #ccc; margin: 10px 0; padding: 15px; border-radius: 5px; }
        .pass { border-color: green; background-color: #f0fff0; }
        .fail { border-color: red; background-color: #fff0f0; }
        .booking { padding: 5px; margin: 2px; background-color: #e0e0ff; display: inline-block; border-radius: 3px; }
        .hole { background-color: #ffcccc; }
        .available { background-color: #ccffcc; }
        .trapped { background-color: #ffffcc; }
        code { background-color: #f5f5f5; padding: 2px 4px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>Test Regola Prevenzione Buchi 30 Minuti</h1>
    <p>Questo file testa la logica implementata per prevenire la creazione di slot inutilizzabili di 30 minuti.</p>

    <h2>Regole Implementate:</h2>
    <ul>
        <li><strong>Regola base:</strong> Non permettere prenotazioni che creano buchi < 30 minuti</li>
        <li><strong>Deroga:</strong> Se tra due prenotazioni ci sono esattamente 120 minuti, permettere una prenotazione da 90 minuti anche se crea un buco da 30 minuti</li>
    </ul>

    <h2>Casi di Test:</h2>

    <div class="test-case" id="test1">
        <h3>Test 1: Buco dopo la prenotazione</h3>
        <p><strong>Scenario:</strong> Prenotazione esistente 12:30-14:00, nuova prenotazione 14:30-15:30</p>
        <p><strong>Atteso:</strong> ‚ùå Non disponibile (creerebbe un buco 14:00-14:30)</p>
        <div id="test1-result"></div>
    </div>

    <div class="test-case" id="test2">
        <h3>Test 2: Buco prima della prenotazione</h3>
        <p><strong>Scenario:</strong> Prenotazione esistente 14:30-16:00, nuova prenotazione 13:30-14:00</p>
        <p><strong>Atteso:</strong> ‚ùå Non disponibile (creerebbe un buco 14:00-14:30)</p>
        <div id="test2-result"></div>
    </div>

    <div class="test-case" id="test3">
        <h3>Test 3: Deroga - Slot intrappolato esatto (120 min)</h3>
        <p><strong>Scenario:</strong> Prenotazioni esistenti 12:00-13:00 e 15:00-16:00, nuova prenotazione 13:00-14:30 (90 min)</p>
        <p><strong>Atteso:</strong> ‚úÖ Disponibile (deroga: esattamente 120 min tra le prenotazioni)</p>
        <div id="test3-result"></div>
    </div>

    <div class="test-case" id="test4">
        <h3>Test 4: NO Deroga - Slot intrappolato non esatto (90 min)</h3>
        <p><strong>Scenario:</strong> Prenotazioni esistenti 12:00-13:00 e 14:30-15:30, nuova prenotazione 13:00-14:00 (60 min)</p>
        <p><strong>Atteso:</strong> ‚ùå Non disponibile (solo 90 min tra prenotazioni, non 120)</p>
        <div id="test4-result"></div>
    </div>

    <div class="test-case" id="test5">
        <h3>Test 5: Prenotazione valida senza buchi</h3>
        <p><strong>Scenario:</strong> Prenotazione esistente 12:00-13:30, nuova prenotazione 13:30-15:00</p>
        <p><strong>Atteso:</strong> ‚úÖ Disponibile (nessun buco creato)</p>
        <div id="test5-result"></div>
    </div>

    <div class="test-case" id="test6">
        <h3>Test 6: Buco esatto di 30 minuti</h3>
        <p><strong>Scenario:</strong> Prenotazione esistente 12:00-13:00, nuova prenotazione 13:30-15:00</p>
        <p><strong>Atteso:</strong> ‚úÖ Disponibile (buco di esattamente 30 min √® ok)</p>
        <div id="test6-result"></div>
    </div>

    <script type="module">
        // Simula le funzioni del servizio unificato
        const BOOKING_STATUS = {
            CONFIRMED: 'confirmed',
            CANCELLED: 'cancelled'
        };

        function timeToMinutes(time) {
            const [hours, minutes] = time.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function wouldCreateHalfHourHole(courtId, date, startTime, duration, existingBookings) {
            const bookingStart = timeToMinutes(startTime);
            const bookingEnd = bookingStart + duration;
            
            // Get bookings for same court and date, sorted by time
            const courtBookings = existingBookings
                .filter(b => 
                    b.courtId === courtId && 
                    b.date === date && 
                    (b.status || BOOKING_STATUS.CONFIRMED) !== BOOKING_STATUS.CANCELLED
                )
                .sort((a, b) => timeToMinutes(a.time) - timeToMinutes(b.time));
            
            // Check for hole after our booking
            const nextBooking = courtBookings.find(b => timeToMinutes(b.time) > bookingEnd);
            if (nextBooking) {
                const nextStart = timeToMinutes(nextBooking.time);
                const holeSize = nextStart - bookingEnd;
                
                if (holeSize > 0 && holeSize < 30) {
                    // Check EXEMPTION: is this part of a trapped slot of EXACTLY 120 minutes?
                    const prevBooking = courtBookings
                        .filter(b => timeToMinutes(b.time) + b.duration <= bookingStart)
                        .pop(); // Get the last one before our booking
                    
                    if (prevBooking) {
                        const prevEnd = timeToMinutes(prevBooking.time) + prevBooking.duration;
                        const totalGap = nextStart - prevEnd;
                        
                        // EXEMPTION: Only if total gap is EXACTLY 120 minutes
                        if (totalGap === 120) {
                            console.log(`üéØ EXEMPTION applied: exactly ${totalGap}min trapped slot allows ${holeSize}min hole`);
                            return false;
                        }
                    }
                    
                    return true; // Would create problematic hole without exemption
                }
            }
            
            // Check for hole before our booking
            const prevBooking = courtBookings
                .filter(b => timeToMinutes(b.time) + b.duration <= bookingStart)
                .pop();
            
            if (prevBooking) {
                const prevEnd = timeToMinutes(prevBooking.time) + prevBooking.duration;
                const holeSize = bookingStart - prevEnd;
                
                if (holeSize > 0 && holeSize < 30) {
                    // Check EXEMPTION: is this part of a trapped slot of EXACTLY 120 minutes?
                    const nextBooking = courtBookings.find(b => timeToMinutes(b.time) >= bookingEnd);
                    
                    if (nextBooking) {
                        const nextStart = timeToMinutes(nextBooking.time);
                        const totalGap = nextStart - prevEnd;
                        
                        // EXEMPTION: Only if total gap is EXACTLY 120 minutes
                        if (totalGap === 120) {
                            console.log(`üéØ EXEMPTION applied: exactly ${totalGap}min trapped slot allows ${holeSize}min hole`);
                            return false;
                        }
                    }
                    
                    return true; // Would create problematic hole without exemption
                }
            }
            
            return false; // No hole would be created
        }

        function runTest(testId, testFn) {
            try {
                const result = testFn();
                const element = document.getElementById(testId);
                element.classList.add(result.pass ? 'pass' : 'fail');
                element.querySelector(`#${testId}-result`).innerHTML = 
                    `<strong>${result.pass ? '‚úÖ PASS' : '‚ùå FAIL'}</strong>: ${result.message}`;
            } catch (error) {
                const element = document.getElementById(testId);
                element.classList.add('fail');
                element.querySelector(`#${testId}-result`).innerHTML = 
                    `<strong>‚ùå ERROR</strong>: ${error.message}`;
            }
        }

        // Test 1: Buco dopo la prenotazione
        runTest('test1', () => {
            const existingBookings = [
                { courtId: 'campo1', date: '2025-01-15', time: '12:30', duration: 90, status: 'confirmed' }
            ];
            const wouldCreateHole = wouldCreateHalfHourHole('campo1', '2025-01-15', '14:30', 60, existingBookings);
            return {
                pass: wouldCreateHole === true,
                message: `wouldCreateHole: ${wouldCreateHole} (dovrebbe essere true)`
            };
        });

        // Test 2: Buco prima della prenotazione
        runTest('test2', () => {
            const existingBookings = [
                { courtId: 'campo1', date: '2025-01-15', time: '14:30', duration: 90, status: 'confirmed' }
            ];
            const wouldCreateHole = wouldCreateHalfHourHole('campo1', '2025-01-15', '13:30', 60, existingBookings);
            return {
                pass: wouldCreateHole === true,
                message: `wouldCreateHole: ${wouldCreateHole} (dovrebbe essere true)`
            };
        });

        // Test 3: Deroga - Slot intrappolato esatto (120 min)
        runTest('test3', () => {
            const existingBookings = [
                { courtId: 'campo1', date: '2025-01-15', time: '12:00', duration: 60, status: 'confirmed' },
                { courtId: 'campo1', date: '2025-01-15', time: '15:00', duration: 60, status: 'confirmed' }
            ];
            const wouldCreateHole = wouldCreateHalfHourHole('campo1', '2025-01-15', '13:00', 90, existingBookings);
            return {
                pass: wouldCreateHole === false,
                message: `wouldCreateHole: ${wouldCreateHole} (dovrebbe essere false - deroga applicata)`
            };
        });

        // Test 4: NO Deroga - Slot intrappolato non esatto (90 min)
        runTest('test4', () => {
            const existingBookings = [
                { courtId: 'campo1', date: '2025-01-15', time: '12:00', duration: 60, status: 'confirmed' },
                { courtId: 'campo1', date: '2025-01-15', time: '14:30', duration: 60, status: 'confirmed' }
            ];
            const wouldCreateHole = wouldCreateHalfHourHole('campo1', '2025-01-15', '13:00', 60, existingBookings);
            return {
                pass: wouldCreateHole === true,
                message: `wouldCreateHole: ${wouldCreateHole} (dovrebbe essere true - no deroga)`
            };
        });

        // Test 5: Prenotazione valida senza buchi
        runTest('test5', () => {
            const existingBookings = [
                { courtId: 'campo1', date: '2025-01-15', time: '12:00', duration: 90, status: 'confirmed' }
            ];
            const wouldCreateHole = wouldCreateHalfHourHole('campo1', '2025-01-15', '13:30', 90, existingBookings);
            return {
                pass: wouldCreateHole === false,
                message: `wouldCreateHole: ${wouldCreateHole} (dovrebbe essere false - nessun buco)`
            };
        });

        // Test 6: Buco esatto di 30 minuti
        runTest('test6', () => {
            const existingBookings = [
                { courtId: 'campo1', date: '2025-01-15', time: '12:00', duration: 60, status: 'confirmed' }
            ];
            const wouldCreateHole = wouldCreateHalfHourHole('campo1', '2025-01-15', '13:30', 90, existingBookings);
            return {
                pass: wouldCreateHole === false,
                message: `wouldCreateHole: ${wouldCreateHole} (dovrebbe essere false - buco di 30min √® ok)`
            };
        });

        console.log('Test della regola prevenzione buchi 30 minuti completati');
    </script>
</body>
</html>
